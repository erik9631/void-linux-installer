#!/bin/bash
function select_from_list() {
  local -n list=$1  # Creates reference to original array
  local max_items=$2
  if ((max_items > 6)); then
    max_items=6
  fi

  local page_count="$((${#list[@]} / max_items))"

  # Add an extra page for remainder items
  if ((${#list[@]} % max_items != 0)); then
    ((page_count++))
  fi

  local current_page=0
  local selected_item_index
  while true; do
    clear
    local selection=0
    local start="$((current_page*max_items))"
    local index=$start
    local end=$((start + max_items < ${#list[@]} ? start + max_items : ${#list[@]}))

    while ((index < end)); do
      echo "$selection ) ${list[$index]}"
      selection=$((selection+1))
      index=$((index+1))
    done

    if (( current_page < page_count - 1)); then
      echo "7 ) Next page"
    fi

    echo " "

    if (( current_page > 0 )); then
      echo "8 ) Previous page"
    fi
    echo "9 ) Exit"
    echo "Page $((current_page)) / $page_count"
    read -r -p "Select an option: " selection
    case $selection in
      [0-6])
        local selected_item_index=$((selection + start))
        if ((selected_item_index < "${#list[@]}")); then
          echo "$selected_item_index"
          return 0
        fi
        ;;
      7)
        if ((current_page+1 < page_count)); then
            current_page=$((current_page+1))
        fi
        ;;
      8)
        if ((current_page-1 >= 0)); then
            current_page=$((current_page-1))
        fi
        ;;
      9)
        return 1
        ;;
    esac
  done
}

function select_time_zone() {
  while true; do
  local timezones
  readarray -t timezones <<< "$(find /usr/share/zoneinfo -maxdepth 1 -type d -printf '%f\n' | grep -E '^[A-Z]')"
  if [[ ${#timezones[@]} -eq 0 ]]; then
      echo "Error: No timezones found"
      return 1
  fi

  local selected_index
  if ! selected_index=$(select_from_list timezones 6); then
    echo "Error: Failed to select timezone"
    return 1
  fi

  local item="${timezones[$selected_index]}"
  local sub_zone
  readarray -t sub_zone <<< "$(find "/usr/share/zoneinfo/$item" -type f -printf '%f\n')"
  local selected_sub_zone
  if ! selected_sub_zone=$(select_from_list sub_zone 6); then
    echo "Error: Failed to select sub-zone"
    continue
  fi
  echo "${timezones[$selected_index]}/${sub_zone[$selected_sub_zone]}"
  break
  done
  return 0
}

function sync_datetime(){
  local selected_time_zone
  if ! selected_time_zone=$(select_time_zone); then
    return 1
  fi

  if ! grep -E "export TZ='$selected_time_zone'" "$HOME"/.bashrc; then
    echo "export TZ=$selected_time_zone" >> "$HOME"/.bashrc
    echo "New time set to to $selected_time_zone" >&2
    return 0
  fi
  sed -i "s/export TZ=.*/export TZ='$selected_time_zone'/" "$HOME"/.bashrc
  echo "Time zone changed to $selected_time_zone" >&2
  export TZ="$selected_time_zone"
  return 0
}



function ask_for_confirmation(){
  local confirmation
  read -r -p "$1 (y/N) " confirmation

  case $confirmation in
    [yY][eE][sS]|[yY])
        return 0
        ;;
    *)
        echo "Operation cancelled by user." >&2
        return 1
        ;;
  esac
}
export -f ask_for_confirmation

# Function for checking if the user is root
function check_root_user() {
  if [ "$(id -u)" != "0" ]; then
    echo "Error: This script must be run as root"
    exit 1
  fi
}
export -f check_root_user

function get_current_stage_from_var() {
    local stage
    stage=$(ls /var/install | grep -Eo 'stage[0-9]' | grep -Eo '[0-9]')

    if [[ -n $stage ]]; then
        echo "$stage"
    else
        >&2 echo "No stage found."
        return 1  # Return an error code if no stage is found.
    fi
}
export -f get_current_stage_from_var

function git_get_files_from_url(){
  local url=$1
  local git_dir
  git_dir=$(mktemp -d git-XXXXXXXXXX)
  local archive="$git_dir/archive.tar.gz"
  if ! wget -O "$archive" "$url"; then
    echo "Error: Failed to download files from $url" >&2
    return 1
  fi
  if ! tar xvzf "$archive" -C "$git_dir" --strip-components=1; then
    echo "Error: Failed to extract files from $archive" >&2
    return 2
  fi
  echo "$git_dir"
}
export -f get_current_stage_from_var

function apply_gtk_theme(){
  if ! dconf load /org/gnome/desktop/interface/ < "$SCRIPT_DIR"/files/system/gtk-theme.dump; then
    echo "Error: Failed to apply GTK theme" >&2
    return 1
  fi
}
export -f apply_gtk_theme


function x_chroot() {
    fail() {
    printf '%s\n' "$1" >&2
    return 1
  }

  if [ "$(id -u)" -ne 0 ]; then
    fail 'xchroot needs to run as root'
  fi

  CHROOT=$1; shift

  [ -d "$CHROOT" ] || fail 'not a directory'
  [ -d "$CHROOT/dev" ] || fail 'no /dev in chroot'
  [ -d "$CHROOT/proc" ] || fail 'no /proc in chroot'
  [ -d "$CHROOT/sys" ] || fail 'no /sys in chroot'

  for _fs in dev proc sys; do
    mount --rbind "/$_fs" "$CHROOT/$_fs"
    mount --make-rslave "$CHROOT/$_fs"
  done

  touch "$CHROOT/etc/resolv.conf"
  mount --bind /etc/resolv.conf "$CHROOT/etc/resolv.conf"

  cleanup() {
    umount -R "$CHROOT/dev" "$CHROOT/proc" "$CHROOT/sys" "$CHROOT/etc/resolv.conf"
  }

  trap cleanup EXIT INT

  if [ -x "$CHROOT/$SHELL" ]; then
    INNER_SHELL="$SHELL"
  elif [ -x "$CHROOT/bin/bash" ]; then
    INNER_SHELL="/bin/bash"
  else
    INNER_SHELL="/bin/sh"
  fi

  printf "\033[1m=> Entering chroot $CHROOT\033[m\n"
  export PS1="[xchroot $CHROOT] $PS1"
  chroot "$CHROOT" "${@:-$INNER_SHELL}"
  STATUS=$?
  if [ $STATUS -ne 0 ]; then
    printf "\033[1m=> Exited chroot $CHROOT\033[m\n"
  else
    printf "\033[1m=> Exited chroot $CHROOT with status $STATUS\033[m\n"
  fi
  exit $STATUS
}

export -f x_chroot